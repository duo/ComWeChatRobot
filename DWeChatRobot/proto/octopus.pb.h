// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: octopus.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_octopus_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_octopus_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_octopus_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_octopus_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_octopus_2eproto;
namespace octopus {
class Binary;
struct BinaryDefaultTypeInternal;
extern BinaryDefaultTypeInternal _Binary_default_instance_;
class Chat;
struct ChatDefaultTypeInternal;
extern ChatDefaultTypeInternal _Chat_default_instance_;
class File;
struct FileDefaultTypeInternal;
extern FileDefaultTypeInternal _File_default_instance_;
class Link;
struct LinkDefaultTypeInternal;
extern LinkDefaultTypeInternal _Link_default_instance_;
class Location;
struct LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class Payload;
struct PayloadDefaultTypeInternal;
extern PayloadDefaultTypeInternal _Payload_default_instance_;
class Photo;
struct PhotoDefaultTypeInternal;
extern PhotoDefaultTypeInternal _Photo_default_instance_;
class Sticker;
struct StickerDefaultTypeInternal;
extern StickerDefaultTypeInternal _Sticker_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class Vendor;
struct VendorDefaultTypeInternal;
extern VendorDefaultTypeInternal _Vendor_default_instance_;
class Video;
struct VideoDefaultTypeInternal;
extern VideoDefaultTypeInternal _Video_default_instance_;
class Voice;
struct VoiceDefaultTypeInternal;
extern VoiceDefaultTypeInternal _Voice_default_instance_;
}  // namespace octopus
PROTOBUF_NAMESPACE_OPEN
template<> ::octopus::Binary* Arena::CreateMaybeMessage<::octopus::Binary>(Arena*);
template<> ::octopus::Chat* Arena::CreateMaybeMessage<::octopus::Chat>(Arena*);
template<> ::octopus::File* Arena::CreateMaybeMessage<::octopus::File>(Arena*);
template<> ::octopus::Link* Arena::CreateMaybeMessage<::octopus::Link>(Arena*);
template<> ::octopus::Location* Arena::CreateMaybeMessage<::octopus::Location>(Arena*);
template<> ::octopus::Message* Arena::CreateMaybeMessage<::octopus::Message>(Arena*);
template<> ::octopus::Payload* Arena::CreateMaybeMessage<::octopus::Payload>(Arena*);
template<> ::octopus::Photo* Arena::CreateMaybeMessage<::octopus::Photo>(Arena*);
template<> ::octopus::Sticker* Arena::CreateMaybeMessage<::octopus::Sticker>(Arena*);
template<> ::octopus::User* Arena::CreateMaybeMessage<::octopus::User>(Arena*);
template<> ::octopus::Vendor* Arena::CreateMaybeMessage<::octopus::Vendor>(Arena*);
template<> ::octopus::Video* Arena::CreateMaybeMessage<::octopus::Video>(Arena*);
template<> ::octopus::Voice* Arena::CreateMaybeMessage<::octopus::Voice>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace octopus {

enum Chat_ChatType : int {
  Chat_ChatType_PRIVATE = 0,
  Chat_ChatType_GROUP = 1,
  Chat_ChatType_Chat_ChatType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Chat_ChatType_Chat_ChatType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Chat_ChatType_IsValid(int value);
constexpr Chat_ChatType Chat_ChatType_ChatType_MIN = Chat_ChatType_PRIVATE;
constexpr Chat_ChatType Chat_ChatType_ChatType_MAX = Chat_ChatType_GROUP;
constexpr int Chat_ChatType_ChatType_ARRAYSIZE = Chat_ChatType_ChatType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Chat_ChatType_descriptor();
template<typename T>
inline const std::string& Chat_ChatType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Chat_ChatType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Chat_ChatType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Chat_ChatType_descriptor(), enum_t_value);
}
inline bool Chat_ChatType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Chat_ChatType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Chat_ChatType>(
    Chat_ChatType_descriptor(), name, value);
}
enum Message_MessageType : int {
  Message_MessageType_TEXT = 0,
  Message_MessageType_PHOTO = 1,
  Message_MessageType_VIDEO = 2,
  Message_MessageType_FILE = 3,
  Message_MessageType_VOICE = 4,
  Message_MessageType_STICKER = 5,
  Message_MessageType_LOCATION = 6,
  Message_MessageType_LINK = 7,
  Message_MessageType_Message_MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Message_MessageType_Message_MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Message_MessageType_IsValid(int value);
constexpr Message_MessageType Message_MessageType_MessageType_MIN = Message_MessageType_TEXT;
constexpr Message_MessageType Message_MessageType_MessageType_MAX = Message_MessageType_LINK;
constexpr int Message_MessageType_MessageType_ARRAYSIZE = Message_MessageType_MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Message_MessageType_descriptor();
template<typename T>
inline const std::string& Message_MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Message_MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Message_MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Message_MessageType_descriptor(), enum_t_value);
}
inline bool Message_MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Message_MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Message_MessageType>(
    Message_MessageType_descriptor(), name, value);
}
enum Payload_PayloadType : int {
  Payload_PayloadType_CHATS = 0,
  Payload_PayloadType_MESSAGE = 1,
  Payload_PayloadType_Payload_PayloadType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Payload_PayloadType_Payload_PayloadType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Payload_PayloadType_IsValid(int value);
constexpr Payload_PayloadType Payload_PayloadType_PayloadType_MIN = Payload_PayloadType_CHATS;
constexpr Payload_PayloadType Payload_PayloadType_PayloadType_MAX = Payload_PayloadType_MESSAGE;
constexpr int Payload_PayloadType_PayloadType_ARRAYSIZE = Payload_PayloadType_PayloadType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Payload_PayloadType_descriptor();
template<typename T>
inline const std::string& Payload_PayloadType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Payload_PayloadType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Payload_PayloadType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Payload_PayloadType_descriptor(), enum_t_value);
}
inline bool Payload_PayloadType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Payload_PayloadType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Payload_PayloadType>(
    Payload_PayloadType_descriptor(), name, value);
}
// ===================================================================

class Binary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:octopus.Binary) */ {
 public:
  inline Binary() : Binary(nullptr) {}
  ~Binary() override;
  explicit PROTOBUF_CONSTEXPR Binary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Binary(const Binary& from);
  Binary(Binary&& from) noexcept
    : Binary() {
    *this = ::std::move(from);
  }

  inline Binary& operator=(const Binary& from) {
    CopyFrom(from);
    return *this;
  }
  inline Binary& operator=(Binary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Binary& default_instance() {
    return *internal_default_instance();
  }
  static inline const Binary* internal_default_instance() {
    return reinterpret_cast<const Binary*>(
               &_Binary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Binary& a, Binary& b) {
    a.Swap(&b);
  }
  inline void Swap(Binary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Binary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Binary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Binary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Binary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Binary& from) {
    Binary::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Binary* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "octopus.Binary";
  }
  protected:
  explicit Binary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMimeFieldNumber = 1,
    kMd5FieldNumber = 2,
    kBlobFieldNumber = 3,
  };
  // string mime = 1;
  void clear_mime();
  const std::string& mime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime();
  PROTOBUF_NODISCARD std::string* release_mime();
  void set_allocated_mime(std::string* mime);
  private:
  const std::string& _internal_mime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime(const std::string& value);
  std::string* _internal_mutable_mime();
  public:

  // string md5 = 2;
  void clear_md5();
  const std::string& md5() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_md5(ArgT0&& arg0, ArgT... args);
  std::string* mutable_md5();
  PROTOBUF_NODISCARD std::string* release_md5();
  void set_allocated_md5(std::string* md5);
  private:
  const std::string& _internal_md5() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_md5(const std::string& value);
  std::string* _internal_mutable_md5();
  public:

  // bytes blob = 3;
  void clear_blob();
  const std::string& blob() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blob(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blob();
  PROTOBUF_NODISCARD std::string* release_blob();
  void set_allocated_blob(std::string* blob);
  private:
  const std::string& _internal_blob() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blob(const std::string& value);
  std::string* _internal_mutable_blob();
  public:

  // @@protoc_insertion_point(class_scope:octopus.Binary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr md5_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blob_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_octopus_2eproto;
};
// -------------------------------------------------------------------

class Photo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:octopus.Photo) */ {
 public:
  inline Photo() : Photo(nullptr) {}
  ~Photo() override;
  explicit PROTOBUF_CONSTEXPR Photo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Photo(const Photo& from);
  Photo(Photo&& from) noexcept
    : Photo() {
    *this = ::std::move(from);
  }

  inline Photo& operator=(const Photo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Photo& operator=(Photo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Photo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Photo* internal_default_instance() {
    return reinterpret_cast<const Photo*>(
               &_Photo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Photo& a, Photo& b) {
    a.Swap(&b);
  }
  inline void Swap(Photo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Photo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Photo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Photo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Photo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Photo& from) {
    Photo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Photo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "octopus.Photo";
  }
  protected:
  explicit Photo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBinFieldNumber = 1,
  };
  // .octopus.Binary bin = 1;
  bool has_bin() const;
  private:
  bool _internal_has_bin() const;
  public:
  void clear_bin();
  const ::octopus::Binary& bin() const;
  PROTOBUF_NODISCARD ::octopus::Binary* release_bin();
  ::octopus::Binary* mutable_bin();
  void set_allocated_bin(::octopus::Binary* bin);
  private:
  const ::octopus::Binary& _internal_bin() const;
  ::octopus::Binary* _internal_mutable_bin();
  public:
  void unsafe_arena_set_allocated_bin(
      ::octopus::Binary* bin);
  ::octopus::Binary* unsafe_arena_release_bin();

  // @@protoc_insertion_point(class_scope:octopus.Photo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::octopus::Binary* bin_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_octopus_2eproto;
};
// -------------------------------------------------------------------

class Video final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:octopus.Video) */ {
 public:
  inline Video() : Video(nullptr) {}
  ~Video() override;
  explicit PROTOBUF_CONSTEXPR Video(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Video(const Video& from);
  Video(Video&& from) noexcept
    : Video() {
    *this = ::std::move(from);
  }

  inline Video& operator=(const Video& from) {
    CopyFrom(from);
    return *this;
  }
  inline Video& operator=(Video&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Video& default_instance() {
    return *internal_default_instance();
  }
  static inline const Video* internal_default_instance() {
    return reinterpret_cast<const Video*>(
               &_Video_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Video& a, Video& b) {
    a.Swap(&b);
  }
  inline void Swap(Video* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Video* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Video* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Video>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Video& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Video& from) {
    Video::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Video* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "octopus.Video";
  }
  protected:
  explicit Video(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBinFieldNumber = 1,
  };
  // .octopus.Binary bin = 1;
  bool has_bin() const;
  private:
  bool _internal_has_bin() const;
  public:
  void clear_bin();
  const ::octopus::Binary& bin() const;
  PROTOBUF_NODISCARD ::octopus::Binary* release_bin();
  ::octopus::Binary* mutable_bin();
  void set_allocated_bin(::octopus::Binary* bin);
  private:
  const ::octopus::Binary& _internal_bin() const;
  ::octopus::Binary* _internal_mutable_bin();
  public:
  void unsafe_arena_set_allocated_bin(
      ::octopus::Binary* bin);
  ::octopus::Binary* unsafe_arena_release_bin();

  // @@protoc_insertion_point(class_scope:octopus.Video)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::octopus::Binary* bin_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_octopus_2eproto;
};
// -------------------------------------------------------------------

class File final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:octopus.File) */ {
 public:
  inline File() : File(nullptr) {}
  ~File() override;
  explicit PROTOBUF_CONSTEXPR File(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  File(const File& from);
  File(File&& from) noexcept
    : File() {
    *this = ::std::move(from);
  }

  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }
  inline File& operator=(File&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const File& default_instance() {
    return *internal_default_instance();
  }
  static inline const File* internal_default_instance() {
    return reinterpret_cast<const File*>(
               &_File_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(File& a, File& b) {
    a.Swap(&b);
  }
  inline void Swap(File* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(File* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  File* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<File>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const File& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const File& from) {
    File::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(File* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "octopus.File";
  }
  protected:
  explicit File(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kBinFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .octopus.Binary bin = 1;
  bool has_bin() const;
  private:
  bool _internal_has_bin() const;
  public:
  void clear_bin();
  const ::octopus::Binary& bin() const;
  PROTOBUF_NODISCARD ::octopus::Binary* release_bin();
  ::octopus::Binary* mutable_bin();
  void set_allocated_bin(::octopus::Binary* bin);
  private:
  const ::octopus::Binary& _internal_bin() const;
  ::octopus::Binary* _internal_mutable_bin();
  public:
  void unsafe_arena_set_allocated_bin(
      ::octopus::Binary* bin);
  ::octopus::Binary* unsafe_arena_release_bin();

  // @@protoc_insertion_point(class_scope:octopus.File)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::octopus::Binary* bin_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_octopus_2eproto;
};
// -------------------------------------------------------------------

class Voice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:octopus.Voice) */ {
 public:
  inline Voice() : Voice(nullptr) {}
  ~Voice() override;
  explicit PROTOBUF_CONSTEXPR Voice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Voice(const Voice& from);
  Voice(Voice&& from) noexcept
    : Voice() {
    *this = ::std::move(from);
  }

  inline Voice& operator=(const Voice& from) {
    CopyFrom(from);
    return *this;
  }
  inline Voice& operator=(Voice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Voice& default_instance() {
    return *internal_default_instance();
  }
  static inline const Voice* internal_default_instance() {
    return reinterpret_cast<const Voice*>(
               &_Voice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Voice& a, Voice& b) {
    a.Swap(&b);
  }
  inline void Swap(Voice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Voice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Voice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Voice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Voice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Voice& from) {
    Voice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Voice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "octopus.Voice";
  }
  protected:
  explicit Voice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBinFieldNumber = 1,
  };
  // .octopus.Binary bin = 1;
  bool has_bin() const;
  private:
  bool _internal_has_bin() const;
  public:
  void clear_bin();
  const ::octopus::Binary& bin() const;
  PROTOBUF_NODISCARD ::octopus::Binary* release_bin();
  ::octopus::Binary* mutable_bin();
  void set_allocated_bin(::octopus::Binary* bin);
  private:
  const ::octopus::Binary& _internal_bin() const;
  ::octopus::Binary* _internal_mutable_bin();
  public:
  void unsafe_arena_set_allocated_bin(
      ::octopus::Binary* bin);
  ::octopus::Binary* unsafe_arena_release_bin();

  // @@protoc_insertion_point(class_scope:octopus.Voice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::octopus::Binary* bin_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_octopus_2eproto;
};
// -------------------------------------------------------------------

class Sticker final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:octopus.Sticker) */ {
 public:
  inline Sticker() : Sticker(nullptr) {}
  ~Sticker() override;
  explicit PROTOBUF_CONSTEXPR Sticker(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Sticker(const Sticker& from);
  Sticker(Sticker&& from) noexcept
    : Sticker() {
    *this = ::std::move(from);
  }

  inline Sticker& operator=(const Sticker& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sticker& operator=(Sticker&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sticker& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sticker* internal_default_instance() {
    return reinterpret_cast<const Sticker*>(
               &_Sticker_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Sticker& a, Sticker& b) {
    a.Swap(&b);
  }
  inline void Swap(Sticker* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sticker* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sticker* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sticker>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Sticker& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Sticker& from) {
    Sticker::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sticker* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "octopus.Sticker";
  }
  protected:
  explicit Sticker(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBinFieldNumber = 1,
  };
  // .octopus.Binary bin = 1;
  bool has_bin() const;
  private:
  bool _internal_has_bin() const;
  public:
  void clear_bin();
  const ::octopus::Binary& bin() const;
  PROTOBUF_NODISCARD ::octopus::Binary* release_bin();
  ::octopus::Binary* mutable_bin();
  void set_allocated_bin(::octopus::Binary* bin);
  private:
  const ::octopus::Binary& _internal_bin() const;
  ::octopus::Binary* _internal_mutable_bin();
  public:
  void unsafe_arena_set_allocated_bin(
      ::octopus::Binary* bin);
  ::octopus::Binary* unsafe_arena_release_bin();

  // @@protoc_insertion_point(class_scope:octopus.Sticker)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::octopus::Binary* bin_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_octopus_2eproto;
};
// -------------------------------------------------------------------

class Location final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:octopus.Location) */ {
 public:
  inline Location() : Location(nullptr) {}
  ~Location() override;
  explicit PROTOBUF_CONSTEXPR Location(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Location(const Location& from);
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  inline Location& operator=(Location&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Location& default_instance() {
    return *internal_default_instance();
  }
  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }
  inline void Swap(Location* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Location* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Location* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Location>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Location& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Location& from) {
    Location::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "octopus.Location";
  }
  protected:
  explicit Location(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLongitudeFieldNumber = 1,
    kLatitudeFieldNumber = 2,
  };
  // double longitude = 1;
  void clear_longitude();
  double longitude() const;
  void set_longitude(double value);
  private:
  double _internal_longitude() const;
  void _internal_set_longitude(double value);
  public:

  // double latitude = 2;
  void clear_latitude();
  double latitude() const;
  void set_latitude(double value);
  private:
  double _internal_latitude() const;
  void _internal_set_latitude(double value);
  public:

  // @@protoc_insertion_point(class_scope:octopus.Location)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double longitude_;
    double latitude_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_octopus_2eproto;
};
// -------------------------------------------------------------------

class Link final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:octopus.Link) */ {
 public:
  inline Link() : Link(nullptr) {}
  ~Link() override;
  explicit PROTOBUF_CONSTEXPR Link(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Link(const Link& from);
  Link(Link&& from) noexcept
    : Link() {
    *this = ::std::move(from);
  }

  inline Link& operator=(const Link& from) {
    CopyFrom(from);
    return *this;
  }
  inline Link& operator=(Link&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Link& default_instance() {
    return *internal_default_instance();
  }
  static inline const Link* internal_default_instance() {
    return reinterpret_cast<const Link*>(
               &_Link_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Link& a, Link& b) {
    a.Swap(&b);
  }
  inline void Swap(Link* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Link* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Link* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Link>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Link& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Link& from) {
    Link::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Link* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "octopus.Link";
  }
  protected:
  explicit Link(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kUrlFieldNumber = 3,
  };
  // string title = 1;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string url = 3;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // @@protoc_insertion_point(class_scope:octopus.Link)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_octopus_2eproto;
};
// -------------------------------------------------------------------

class User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:octopus.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit PROTOBUF_CONSTEXPR User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const User& from) {
    User::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "octopus.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kUsernameFieldNumber = 2,
    kRemarkFieldNumber = 3,
  };
  // string uid = 1;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // string username = 2;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string remark = 3;
  void clear_remark();
  const std::string& remark() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remark(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remark();
  PROTOBUF_NODISCARD std::string* release_remark();
  void set_allocated_remark(std::string* remark);
  private:
  const std::string& _internal_remark() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remark(const std::string& value);
  std::string* _internal_mutable_remark();
  public:

  // @@protoc_insertion_point(class_scope:octopus.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remark_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_octopus_2eproto;
};
// -------------------------------------------------------------------

class Chat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:octopus.Chat) */ {
 public:
  inline Chat() : Chat(nullptr) {}
  ~Chat() override;
  explicit PROTOBUF_CONSTEXPR Chat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Chat(const Chat& from);
  Chat(Chat&& from) noexcept
    : Chat() {
    *this = ::std::move(from);
  }

  inline Chat& operator=(const Chat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Chat& operator=(Chat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Chat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Chat* internal_default_instance() {
    return reinterpret_cast<const Chat*>(
               &_Chat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Chat& a, Chat& b) {
    a.Swap(&b);
  }
  inline void Swap(Chat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Chat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Chat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Chat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Chat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Chat& from) {
    Chat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Chat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "octopus.Chat";
  }
  protected:
  explicit Chat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Chat_ChatType ChatType;
  static constexpr ChatType PRIVATE =
    Chat_ChatType_PRIVATE;
  static constexpr ChatType GROUP =
    Chat_ChatType_GROUP;
  static inline bool ChatType_IsValid(int value) {
    return Chat_ChatType_IsValid(value);
  }
  static constexpr ChatType ChatType_MIN =
    Chat_ChatType_ChatType_MIN;
  static constexpr ChatType ChatType_MAX =
    Chat_ChatType_ChatType_MAX;
  static constexpr int ChatType_ARRAYSIZE =
    Chat_ChatType_ChatType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ChatType_descriptor() {
    return Chat_ChatType_descriptor();
  }
  template<typename T>
  static inline const std::string& ChatType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ChatType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ChatType_Name.");
    return Chat_ChatType_Name(enum_t_value);
  }
  static inline bool ChatType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ChatType* value) {
    return Chat_ChatType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kTitleFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // string uid = 1;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // string title = 3;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // .octopus.Chat.ChatType type = 2;
  void clear_type();
  ::octopus::Chat_ChatType type() const;
  void set_type(::octopus::Chat_ChatType value);
  private:
  ::octopus::Chat_ChatType _internal_type() const;
  void _internal_set_type(::octopus::Chat_ChatType value);
  public:

  // @@protoc_insertion_point(class_scope:octopus.Chat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_octopus_2eproto;
};
// -------------------------------------------------------------------

class Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:octopus.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  explicit PROTOBUF_CONSTEXPR Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Message& from) {
    Message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "octopus.Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Message_MessageType MessageType;
  static constexpr MessageType TEXT =
    Message_MessageType_TEXT;
  static constexpr MessageType PHOTO =
    Message_MessageType_PHOTO;
  static constexpr MessageType VIDEO =
    Message_MessageType_VIDEO;
  static constexpr MessageType FILE =
    Message_MessageType_FILE;
  static constexpr MessageType VOICE =
    Message_MessageType_VOICE;
  static constexpr MessageType STICKER =
    Message_MessageType_STICKER;
  static constexpr MessageType LOCATION =
    Message_MessageType_LOCATION;
  static constexpr MessageType LINK =
    Message_MessageType_LINK;
  static inline bool MessageType_IsValid(int value) {
    return Message_MessageType_IsValid(value);
  }
  static constexpr MessageType MessageType_MIN =
    Message_MessageType_MessageType_MIN;
  static constexpr MessageType MessageType_MAX =
    Message_MessageType_MessageType_MAX;
  static constexpr int MessageType_ARRAYSIZE =
    Message_MessageType_MessageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MessageType_descriptor() {
    return Message_MessageType_descriptor();
  }
  template<typename T>
  static inline const std::string& MessageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MessageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MessageType_Name.");
    return Message_MessageType_Name(enum_t_value);
  }
  static inline bool MessageType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MessageType* value) {
    return Message_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPhotosFieldNumber = 100,
    kTextFieldNumber = 6,
    kFromFieldNumber = 4,
    kChatFieldNumber = 5,
    kReplyToMessageFieldNumber = 7,
    kVideoFieldNumber = 101,
    kFileFieldNumber = 102,
    kVoiceFieldNumber = 103,
    kStickerFieldNumber = 104,
    kLocationFieldNumber = 105,
    kLinkFieldNumber = 106,
    kMessageIdFieldNumber = 1,
    kDateFieldNumber = 2,
    kEditDateFieldNumber = 3,
    kTypeFieldNumber = 99,
  };
  // repeated .octopus.Photo photos = 100;
  int photos_size() const;
  private:
  int _internal_photos_size() const;
  public:
  void clear_photos();
  ::octopus::Photo* mutable_photos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::octopus::Photo >*
      mutable_photos();
  private:
  const ::octopus::Photo& _internal_photos(int index) const;
  ::octopus::Photo* _internal_add_photos();
  public:
  const ::octopus::Photo& photos(int index) const;
  ::octopus::Photo* add_photos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::octopus::Photo >&
      photos() const;

  // string text = 6;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .octopus.User from = 4;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  const ::octopus::User& from() const;
  PROTOBUF_NODISCARD ::octopus::User* release_from();
  ::octopus::User* mutable_from();
  void set_allocated_from(::octopus::User* from);
  private:
  const ::octopus::User& _internal_from() const;
  ::octopus::User* _internal_mutable_from();
  public:
  void unsafe_arena_set_allocated_from(
      ::octopus::User* from);
  ::octopus::User* unsafe_arena_release_from();

  // .octopus.Chat Chat = 5;
  bool has_chat() const;
  private:
  bool _internal_has_chat() const;
  public:
  void clear_chat();
  const ::octopus::Chat& chat() const;
  PROTOBUF_NODISCARD ::octopus::Chat* release_chat();
  ::octopus::Chat* mutable_chat();
  void set_allocated_chat(::octopus::Chat* chat);
  private:
  const ::octopus::Chat& _internal_chat() const;
  ::octopus::Chat* _internal_mutable_chat();
  public:
  void unsafe_arena_set_allocated_chat(
      ::octopus::Chat* chat);
  ::octopus::Chat* unsafe_arena_release_chat();

  // .octopus.Message reply_to_message = 7;
  bool has_reply_to_message() const;
  private:
  bool _internal_has_reply_to_message() const;
  public:
  void clear_reply_to_message();
  const ::octopus::Message& reply_to_message() const;
  PROTOBUF_NODISCARD ::octopus::Message* release_reply_to_message();
  ::octopus::Message* mutable_reply_to_message();
  void set_allocated_reply_to_message(::octopus::Message* reply_to_message);
  private:
  const ::octopus::Message& _internal_reply_to_message() const;
  ::octopus::Message* _internal_mutable_reply_to_message();
  public:
  void unsafe_arena_set_allocated_reply_to_message(
      ::octopus::Message* reply_to_message);
  ::octopus::Message* unsafe_arena_release_reply_to_message();

  // .octopus.Video video = 101;
  bool has_video() const;
  private:
  bool _internal_has_video() const;
  public:
  void clear_video();
  const ::octopus::Video& video() const;
  PROTOBUF_NODISCARD ::octopus::Video* release_video();
  ::octopus::Video* mutable_video();
  void set_allocated_video(::octopus::Video* video);
  private:
  const ::octopus::Video& _internal_video() const;
  ::octopus::Video* _internal_mutable_video();
  public:
  void unsafe_arena_set_allocated_video(
      ::octopus::Video* video);
  ::octopus::Video* unsafe_arena_release_video();

  // .octopus.File file = 102;
  bool has_file() const;
  private:
  bool _internal_has_file() const;
  public:
  void clear_file();
  const ::octopus::File& file() const;
  PROTOBUF_NODISCARD ::octopus::File* release_file();
  ::octopus::File* mutable_file();
  void set_allocated_file(::octopus::File* file);
  private:
  const ::octopus::File& _internal_file() const;
  ::octopus::File* _internal_mutable_file();
  public:
  void unsafe_arena_set_allocated_file(
      ::octopus::File* file);
  ::octopus::File* unsafe_arena_release_file();

  // .octopus.Voice voice = 103;
  bool has_voice() const;
  private:
  bool _internal_has_voice() const;
  public:
  void clear_voice();
  const ::octopus::Voice& voice() const;
  PROTOBUF_NODISCARD ::octopus::Voice* release_voice();
  ::octopus::Voice* mutable_voice();
  void set_allocated_voice(::octopus::Voice* voice);
  private:
  const ::octopus::Voice& _internal_voice() const;
  ::octopus::Voice* _internal_mutable_voice();
  public:
  void unsafe_arena_set_allocated_voice(
      ::octopus::Voice* voice);
  ::octopus::Voice* unsafe_arena_release_voice();

  // .octopus.Sticker sticker = 104;
  bool has_sticker() const;
  private:
  bool _internal_has_sticker() const;
  public:
  void clear_sticker();
  const ::octopus::Sticker& sticker() const;
  PROTOBUF_NODISCARD ::octopus::Sticker* release_sticker();
  ::octopus::Sticker* mutable_sticker();
  void set_allocated_sticker(::octopus::Sticker* sticker);
  private:
  const ::octopus::Sticker& _internal_sticker() const;
  ::octopus::Sticker* _internal_mutable_sticker();
  public:
  void unsafe_arena_set_allocated_sticker(
      ::octopus::Sticker* sticker);
  ::octopus::Sticker* unsafe_arena_release_sticker();

  // .octopus.Location location = 105;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::octopus::Location& location() const;
  PROTOBUF_NODISCARD ::octopus::Location* release_location();
  ::octopus::Location* mutable_location();
  void set_allocated_location(::octopus::Location* location);
  private:
  const ::octopus::Location& _internal_location() const;
  ::octopus::Location* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::octopus::Location* location);
  ::octopus::Location* unsafe_arena_release_location();

  // .octopus.Link link = 106;
  bool has_link() const;
  private:
  bool _internal_has_link() const;
  public:
  void clear_link();
  const ::octopus::Link& link() const;
  PROTOBUF_NODISCARD ::octopus::Link* release_link();
  ::octopus::Link* mutable_link();
  void set_allocated_link(::octopus::Link* link);
  private:
  const ::octopus::Link& _internal_link() const;
  ::octopus::Link* _internal_mutable_link();
  public:
  void unsafe_arena_set_allocated_link(
      ::octopus::Link* link);
  ::octopus::Link* unsafe_arena_release_link();

  // int64 message_id = 1;
  void clear_message_id();
  int64_t message_id() const;
  void set_message_id(int64_t value);
  private:
  int64_t _internal_message_id() const;
  void _internal_set_message_id(int64_t value);
  public:

  // int64 date = 2;
  void clear_date();
  int64_t date() const;
  void set_date(int64_t value);
  private:
  int64_t _internal_date() const;
  void _internal_set_date(int64_t value);
  public:

  // int64 edit_date = 3;
  void clear_edit_date();
  int64_t edit_date() const;
  void set_edit_date(int64_t value);
  private:
  int64_t _internal_edit_date() const;
  void _internal_set_edit_date(int64_t value);
  public:

  // .octopus.Message.MessageType type = 99;
  void clear_type();
  ::octopus::Message_MessageType type() const;
  void set_type(::octopus::Message_MessageType value);
  private:
  ::octopus::Message_MessageType _internal_type() const;
  void _internal_set_type(::octopus::Message_MessageType value);
  public:

  // @@protoc_insertion_point(class_scope:octopus.Message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::octopus::Photo > photos_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::octopus::User* from_;
    ::octopus::Chat* chat_;
    ::octopus::Message* reply_to_message_;
    ::octopus::Video* video_;
    ::octopus::File* file_;
    ::octopus::Voice* voice_;
    ::octopus::Sticker* sticker_;
    ::octopus::Location* location_;
    ::octopus::Link* link_;
    int64_t message_id_;
    int64_t date_;
    int64_t edit_date_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_octopus_2eproto;
};
// -------------------------------------------------------------------

class Vendor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:octopus.Vendor) */ {
 public:
  inline Vendor() : Vendor(nullptr) {}
  ~Vendor() override;
  explicit PROTOBUF_CONSTEXPR Vendor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vendor(const Vendor& from);
  Vendor(Vendor&& from) noexcept
    : Vendor() {
    *this = ::std::move(from);
  }

  inline Vendor& operator=(const Vendor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vendor& operator=(Vendor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vendor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vendor* internal_default_instance() {
    return reinterpret_cast<const Vendor*>(
               &_Vendor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Vendor& a, Vendor& b) {
    a.Swap(&b);
  }
  inline void Swap(Vendor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vendor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vendor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vendor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vendor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vendor& from) {
    Vendor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vendor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "octopus.Vendor";
  }
  protected:
  explicit Vendor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string uid = 1;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // string type = 2;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:octopus.Vendor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_octopus_2eproto;
};
// -------------------------------------------------------------------

class Payload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:octopus.Payload) */ {
 public:
  inline Payload() : Payload(nullptr) {}
  ~Payload() override;
  explicit PROTOBUF_CONSTEXPR Payload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Payload(const Payload& from);
  Payload(Payload&& from) noexcept
    : Payload() {
    *this = ::std::move(from);
  }

  inline Payload& operator=(const Payload& from) {
    CopyFrom(from);
    return *this;
  }
  inline Payload& operator=(Payload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Payload& default_instance() {
    return *internal_default_instance();
  }
  static inline const Payload* internal_default_instance() {
    return reinterpret_cast<const Payload*>(
               &_Payload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Payload& a, Payload& b) {
    a.Swap(&b);
  }
  inline void Swap(Payload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Payload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Payload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Payload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Payload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Payload& from) {
    Payload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Payload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "octopus.Payload";
  }
  protected:
  explicit Payload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Payload_PayloadType PayloadType;
  static constexpr PayloadType CHATS =
    Payload_PayloadType_CHATS;
  static constexpr PayloadType MESSAGE =
    Payload_PayloadType_MESSAGE;
  static inline bool PayloadType_IsValid(int value) {
    return Payload_PayloadType_IsValid(value);
  }
  static constexpr PayloadType PayloadType_MIN =
    Payload_PayloadType_PayloadType_MIN;
  static constexpr PayloadType PayloadType_MAX =
    Payload_PayloadType_PayloadType_MAX;
  static constexpr int PayloadType_ARRAYSIZE =
    Payload_PayloadType_PayloadType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PayloadType_descriptor() {
    return Payload_PayloadType_descriptor();
  }
  template<typename T>
  static inline const std::string& PayloadType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PayloadType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PayloadType_Name.");
    return Payload_PayloadType_Name(enum_t_value);
  }
  static inline bool PayloadType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PayloadType* value) {
    return Payload_PayloadType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kChatsFieldNumber = 4,
    kUidFieldNumber = 1,
    kVendorFieldNumber = 2,
    kMessageFieldNumber = 5,
    kTypeFieldNumber = 3,
  };
  // repeated .octopus.Chat chats = 4;
  int chats_size() const;
  private:
  int _internal_chats_size() const;
  public:
  void clear_chats();
  ::octopus::Chat* mutable_chats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::octopus::Chat >*
      mutable_chats();
  private:
  const ::octopus::Chat& _internal_chats(int index) const;
  ::octopus::Chat* _internal_add_chats();
  public:
  const ::octopus::Chat& chats(int index) const;
  ::octopus::Chat* add_chats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::octopus::Chat >&
      chats() const;

  // string uid = 1;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // .octopus.Vendor vendor = 2;
  bool has_vendor() const;
  private:
  bool _internal_has_vendor() const;
  public:
  void clear_vendor();
  const ::octopus::Vendor& vendor() const;
  PROTOBUF_NODISCARD ::octopus::Vendor* release_vendor();
  ::octopus::Vendor* mutable_vendor();
  void set_allocated_vendor(::octopus::Vendor* vendor);
  private:
  const ::octopus::Vendor& _internal_vendor() const;
  ::octopus::Vendor* _internal_mutable_vendor();
  public:
  void unsafe_arena_set_allocated_vendor(
      ::octopus::Vendor* vendor);
  ::octopus::Vendor* unsafe_arena_release_vendor();

  // .octopus.Message message = 5;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::octopus::Message& message() const;
  PROTOBUF_NODISCARD ::octopus::Message* release_message();
  ::octopus::Message* mutable_message();
  void set_allocated_message(::octopus::Message* message);
  private:
  const ::octopus::Message& _internal_message() const;
  ::octopus::Message* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::octopus::Message* message);
  ::octopus::Message* unsafe_arena_release_message();

  // .octopus.Payload.PayloadType type = 3;
  void clear_type();
  ::octopus::Payload_PayloadType type() const;
  void set_type(::octopus::Payload_PayloadType value);
  private:
  ::octopus::Payload_PayloadType _internal_type() const;
  void _internal_set_type(::octopus::Payload_PayloadType value);
  public:

  // @@protoc_insertion_point(class_scope:octopus.Payload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::octopus::Chat > chats_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    ::octopus::Vendor* vendor_;
    ::octopus::Message* message_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_octopus_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Binary

// string mime = 1;
inline void Binary::clear_mime() {
  _impl_.mime_.ClearToEmpty();
}
inline const std::string& Binary::mime() const {
  // @@protoc_insertion_point(field_get:octopus.Binary.mime)
  return _internal_mime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Binary::set_mime(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mime_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:octopus.Binary.mime)
}
inline std::string* Binary::mutable_mime() {
  std::string* _s = _internal_mutable_mime();
  // @@protoc_insertion_point(field_mutable:octopus.Binary.mime)
  return _s;
}
inline const std::string& Binary::_internal_mime() const {
  return _impl_.mime_.Get();
}
inline void Binary::_internal_set_mime(const std::string& value) {
  
  _impl_.mime_.Set(value, GetArenaForAllocation());
}
inline std::string* Binary::_internal_mutable_mime() {
  
  return _impl_.mime_.Mutable(GetArenaForAllocation());
}
inline std::string* Binary::release_mime() {
  // @@protoc_insertion_point(field_release:octopus.Binary.mime)
  return _impl_.mime_.Release();
}
inline void Binary::set_allocated_mime(std::string* mime) {
  if (mime != nullptr) {
    
  } else {
    
  }
  _impl_.mime_.SetAllocated(mime, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_.IsDefault()) {
    _impl_.mime_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:octopus.Binary.mime)
}

// string md5 = 2;
inline void Binary::clear_md5() {
  _impl_.md5_.ClearToEmpty();
}
inline const std::string& Binary::md5() const {
  // @@protoc_insertion_point(field_get:octopus.Binary.md5)
  return _internal_md5();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Binary::set_md5(ArgT0&& arg0, ArgT... args) {
 
 _impl_.md5_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:octopus.Binary.md5)
}
inline std::string* Binary::mutable_md5() {
  std::string* _s = _internal_mutable_md5();
  // @@protoc_insertion_point(field_mutable:octopus.Binary.md5)
  return _s;
}
inline const std::string& Binary::_internal_md5() const {
  return _impl_.md5_.Get();
}
inline void Binary::_internal_set_md5(const std::string& value) {
  
  _impl_.md5_.Set(value, GetArenaForAllocation());
}
inline std::string* Binary::_internal_mutable_md5() {
  
  return _impl_.md5_.Mutable(GetArenaForAllocation());
}
inline std::string* Binary::release_md5() {
  // @@protoc_insertion_point(field_release:octopus.Binary.md5)
  return _impl_.md5_.Release();
}
inline void Binary::set_allocated_md5(std::string* md5) {
  if (md5 != nullptr) {
    
  } else {
    
  }
  _impl_.md5_.SetAllocated(md5, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.md5_.IsDefault()) {
    _impl_.md5_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:octopus.Binary.md5)
}

// bytes blob = 3;
inline void Binary::clear_blob() {
  _impl_.blob_.ClearToEmpty();
}
inline const std::string& Binary::blob() const {
  // @@protoc_insertion_point(field_get:octopus.Binary.blob)
  return _internal_blob();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Binary::set_blob(ArgT0&& arg0, ArgT... args) {
 
 _impl_.blob_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:octopus.Binary.blob)
}
inline std::string* Binary::mutable_blob() {
  std::string* _s = _internal_mutable_blob();
  // @@protoc_insertion_point(field_mutable:octopus.Binary.blob)
  return _s;
}
inline const std::string& Binary::_internal_blob() const {
  return _impl_.blob_.Get();
}
inline void Binary::_internal_set_blob(const std::string& value) {
  
  _impl_.blob_.Set(value, GetArenaForAllocation());
}
inline std::string* Binary::_internal_mutable_blob() {
  
  return _impl_.blob_.Mutable(GetArenaForAllocation());
}
inline std::string* Binary::release_blob() {
  // @@protoc_insertion_point(field_release:octopus.Binary.blob)
  return _impl_.blob_.Release();
}
inline void Binary::set_allocated_blob(std::string* blob) {
  if (blob != nullptr) {
    
  } else {
    
  }
  _impl_.blob_.SetAllocated(blob, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.blob_.IsDefault()) {
    _impl_.blob_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:octopus.Binary.blob)
}

// -------------------------------------------------------------------

// Photo

// .octopus.Binary bin = 1;
inline bool Photo::_internal_has_bin() const {
  return this != internal_default_instance() && _impl_.bin_ != nullptr;
}
inline bool Photo::has_bin() const {
  return _internal_has_bin();
}
inline void Photo::clear_bin() {
  if (GetArenaForAllocation() == nullptr && _impl_.bin_ != nullptr) {
    delete _impl_.bin_;
  }
  _impl_.bin_ = nullptr;
}
inline const ::octopus::Binary& Photo::_internal_bin() const {
  const ::octopus::Binary* p = _impl_.bin_;
  return p != nullptr ? *p : reinterpret_cast<const ::octopus::Binary&>(
      ::octopus::_Binary_default_instance_);
}
inline const ::octopus::Binary& Photo::bin() const {
  // @@protoc_insertion_point(field_get:octopus.Photo.bin)
  return _internal_bin();
}
inline void Photo::unsafe_arena_set_allocated_bin(
    ::octopus::Binary* bin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bin_);
  }
  _impl_.bin_ = bin;
  if (bin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:octopus.Photo.bin)
}
inline ::octopus::Binary* Photo::release_bin() {
  
  ::octopus::Binary* temp = _impl_.bin_;
  _impl_.bin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::octopus::Binary* Photo::unsafe_arena_release_bin() {
  // @@protoc_insertion_point(field_release:octopus.Photo.bin)
  
  ::octopus::Binary* temp = _impl_.bin_;
  _impl_.bin_ = nullptr;
  return temp;
}
inline ::octopus::Binary* Photo::_internal_mutable_bin() {
  
  if (_impl_.bin_ == nullptr) {
    auto* p = CreateMaybeMessage<::octopus::Binary>(GetArenaForAllocation());
    _impl_.bin_ = p;
  }
  return _impl_.bin_;
}
inline ::octopus::Binary* Photo::mutable_bin() {
  ::octopus::Binary* _msg = _internal_mutable_bin();
  // @@protoc_insertion_point(field_mutable:octopus.Photo.bin)
  return _msg;
}
inline void Photo::set_allocated_bin(::octopus::Binary* bin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bin_;
  }
  if (bin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bin);
    if (message_arena != submessage_arena) {
      bin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bin, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.bin_ = bin;
  // @@protoc_insertion_point(field_set_allocated:octopus.Photo.bin)
}

// -------------------------------------------------------------------

// Video

// .octopus.Binary bin = 1;
inline bool Video::_internal_has_bin() const {
  return this != internal_default_instance() && _impl_.bin_ != nullptr;
}
inline bool Video::has_bin() const {
  return _internal_has_bin();
}
inline void Video::clear_bin() {
  if (GetArenaForAllocation() == nullptr && _impl_.bin_ != nullptr) {
    delete _impl_.bin_;
  }
  _impl_.bin_ = nullptr;
}
inline const ::octopus::Binary& Video::_internal_bin() const {
  const ::octopus::Binary* p = _impl_.bin_;
  return p != nullptr ? *p : reinterpret_cast<const ::octopus::Binary&>(
      ::octopus::_Binary_default_instance_);
}
inline const ::octopus::Binary& Video::bin() const {
  // @@protoc_insertion_point(field_get:octopus.Video.bin)
  return _internal_bin();
}
inline void Video::unsafe_arena_set_allocated_bin(
    ::octopus::Binary* bin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bin_);
  }
  _impl_.bin_ = bin;
  if (bin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:octopus.Video.bin)
}
inline ::octopus::Binary* Video::release_bin() {
  
  ::octopus::Binary* temp = _impl_.bin_;
  _impl_.bin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::octopus::Binary* Video::unsafe_arena_release_bin() {
  // @@protoc_insertion_point(field_release:octopus.Video.bin)
  
  ::octopus::Binary* temp = _impl_.bin_;
  _impl_.bin_ = nullptr;
  return temp;
}
inline ::octopus::Binary* Video::_internal_mutable_bin() {
  
  if (_impl_.bin_ == nullptr) {
    auto* p = CreateMaybeMessage<::octopus::Binary>(GetArenaForAllocation());
    _impl_.bin_ = p;
  }
  return _impl_.bin_;
}
inline ::octopus::Binary* Video::mutable_bin() {
  ::octopus::Binary* _msg = _internal_mutable_bin();
  // @@protoc_insertion_point(field_mutable:octopus.Video.bin)
  return _msg;
}
inline void Video::set_allocated_bin(::octopus::Binary* bin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bin_;
  }
  if (bin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bin);
    if (message_arena != submessage_arena) {
      bin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bin, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.bin_ = bin;
  // @@protoc_insertion_point(field_set_allocated:octopus.Video.bin)
}

// -------------------------------------------------------------------

// File

// .octopus.Binary bin = 1;
inline bool File::_internal_has_bin() const {
  return this != internal_default_instance() && _impl_.bin_ != nullptr;
}
inline bool File::has_bin() const {
  return _internal_has_bin();
}
inline void File::clear_bin() {
  if (GetArenaForAllocation() == nullptr && _impl_.bin_ != nullptr) {
    delete _impl_.bin_;
  }
  _impl_.bin_ = nullptr;
}
inline const ::octopus::Binary& File::_internal_bin() const {
  const ::octopus::Binary* p = _impl_.bin_;
  return p != nullptr ? *p : reinterpret_cast<const ::octopus::Binary&>(
      ::octopus::_Binary_default_instance_);
}
inline const ::octopus::Binary& File::bin() const {
  // @@protoc_insertion_point(field_get:octopus.File.bin)
  return _internal_bin();
}
inline void File::unsafe_arena_set_allocated_bin(
    ::octopus::Binary* bin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bin_);
  }
  _impl_.bin_ = bin;
  if (bin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:octopus.File.bin)
}
inline ::octopus::Binary* File::release_bin() {
  
  ::octopus::Binary* temp = _impl_.bin_;
  _impl_.bin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::octopus::Binary* File::unsafe_arena_release_bin() {
  // @@protoc_insertion_point(field_release:octopus.File.bin)
  
  ::octopus::Binary* temp = _impl_.bin_;
  _impl_.bin_ = nullptr;
  return temp;
}
inline ::octopus::Binary* File::_internal_mutable_bin() {
  
  if (_impl_.bin_ == nullptr) {
    auto* p = CreateMaybeMessage<::octopus::Binary>(GetArenaForAllocation());
    _impl_.bin_ = p;
  }
  return _impl_.bin_;
}
inline ::octopus::Binary* File::mutable_bin() {
  ::octopus::Binary* _msg = _internal_mutable_bin();
  // @@protoc_insertion_point(field_mutable:octopus.File.bin)
  return _msg;
}
inline void File::set_allocated_bin(::octopus::Binary* bin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bin_;
  }
  if (bin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bin);
    if (message_arena != submessage_arena) {
      bin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bin, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.bin_ = bin;
  // @@protoc_insertion_point(field_set_allocated:octopus.File.bin)
}

// string name = 2;
inline void File::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& File::name() const {
  // @@protoc_insertion_point(field_get:octopus.File.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void File::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:octopus.File.name)
}
inline std::string* File::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:octopus.File.name)
  return _s;
}
inline const std::string& File::_internal_name() const {
  return _impl_.name_.Get();
}
inline void File::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* File::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* File::release_name() {
  // @@protoc_insertion_point(field_release:octopus.File.name)
  return _impl_.name_.Release();
}
inline void File::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:octopus.File.name)
}

// -------------------------------------------------------------------

// Voice

// .octopus.Binary bin = 1;
inline bool Voice::_internal_has_bin() const {
  return this != internal_default_instance() && _impl_.bin_ != nullptr;
}
inline bool Voice::has_bin() const {
  return _internal_has_bin();
}
inline void Voice::clear_bin() {
  if (GetArenaForAllocation() == nullptr && _impl_.bin_ != nullptr) {
    delete _impl_.bin_;
  }
  _impl_.bin_ = nullptr;
}
inline const ::octopus::Binary& Voice::_internal_bin() const {
  const ::octopus::Binary* p = _impl_.bin_;
  return p != nullptr ? *p : reinterpret_cast<const ::octopus::Binary&>(
      ::octopus::_Binary_default_instance_);
}
inline const ::octopus::Binary& Voice::bin() const {
  // @@protoc_insertion_point(field_get:octopus.Voice.bin)
  return _internal_bin();
}
inline void Voice::unsafe_arena_set_allocated_bin(
    ::octopus::Binary* bin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bin_);
  }
  _impl_.bin_ = bin;
  if (bin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:octopus.Voice.bin)
}
inline ::octopus::Binary* Voice::release_bin() {
  
  ::octopus::Binary* temp = _impl_.bin_;
  _impl_.bin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::octopus::Binary* Voice::unsafe_arena_release_bin() {
  // @@protoc_insertion_point(field_release:octopus.Voice.bin)
  
  ::octopus::Binary* temp = _impl_.bin_;
  _impl_.bin_ = nullptr;
  return temp;
}
inline ::octopus::Binary* Voice::_internal_mutable_bin() {
  
  if (_impl_.bin_ == nullptr) {
    auto* p = CreateMaybeMessage<::octopus::Binary>(GetArenaForAllocation());
    _impl_.bin_ = p;
  }
  return _impl_.bin_;
}
inline ::octopus::Binary* Voice::mutable_bin() {
  ::octopus::Binary* _msg = _internal_mutable_bin();
  // @@protoc_insertion_point(field_mutable:octopus.Voice.bin)
  return _msg;
}
inline void Voice::set_allocated_bin(::octopus::Binary* bin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bin_;
  }
  if (bin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bin);
    if (message_arena != submessage_arena) {
      bin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bin, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.bin_ = bin;
  // @@protoc_insertion_point(field_set_allocated:octopus.Voice.bin)
}

// -------------------------------------------------------------------

// Sticker

// .octopus.Binary bin = 1;
inline bool Sticker::_internal_has_bin() const {
  return this != internal_default_instance() && _impl_.bin_ != nullptr;
}
inline bool Sticker::has_bin() const {
  return _internal_has_bin();
}
inline void Sticker::clear_bin() {
  if (GetArenaForAllocation() == nullptr && _impl_.bin_ != nullptr) {
    delete _impl_.bin_;
  }
  _impl_.bin_ = nullptr;
}
inline const ::octopus::Binary& Sticker::_internal_bin() const {
  const ::octopus::Binary* p = _impl_.bin_;
  return p != nullptr ? *p : reinterpret_cast<const ::octopus::Binary&>(
      ::octopus::_Binary_default_instance_);
}
inline const ::octopus::Binary& Sticker::bin() const {
  // @@protoc_insertion_point(field_get:octopus.Sticker.bin)
  return _internal_bin();
}
inline void Sticker::unsafe_arena_set_allocated_bin(
    ::octopus::Binary* bin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bin_);
  }
  _impl_.bin_ = bin;
  if (bin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:octopus.Sticker.bin)
}
inline ::octopus::Binary* Sticker::release_bin() {
  
  ::octopus::Binary* temp = _impl_.bin_;
  _impl_.bin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::octopus::Binary* Sticker::unsafe_arena_release_bin() {
  // @@protoc_insertion_point(field_release:octopus.Sticker.bin)
  
  ::octopus::Binary* temp = _impl_.bin_;
  _impl_.bin_ = nullptr;
  return temp;
}
inline ::octopus::Binary* Sticker::_internal_mutable_bin() {
  
  if (_impl_.bin_ == nullptr) {
    auto* p = CreateMaybeMessage<::octopus::Binary>(GetArenaForAllocation());
    _impl_.bin_ = p;
  }
  return _impl_.bin_;
}
inline ::octopus::Binary* Sticker::mutable_bin() {
  ::octopus::Binary* _msg = _internal_mutable_bin();
  // @@protoc_insertion_point(field_mutable:octopus.Sticker.bin)
  return _msg;
}
inline void Sticker::set_allocated_bin(::octopus::Binary* bin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bin_;
  }
  if (bin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bin);
    if (message_arena != submessage_arena) {
      bin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bin, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.bin_ = bin;
  // @@protoc_insertion_point(field_set_allocated:octopus.Sticker.bin)
}

// -------------------------------------------------------------------

// Location

// double longitude = 1;
inline void Location::clear_longitude() {
  _impl_.longitude_ = 0;
}
inline double Location::_internal_longitude() const {
  return _impl_.longitude_;
}
inline double Location::longitude() const {
  // @@protoc_insertion_point(field_get:octopus.Location.longitude)
  return _internal_longitude();
}
inline void Location::_internal_set_longitude(double value) {
  
  _impl_.longitude_ = value;
}
inline void Location::set_longitude(double value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:octopus.Location.longitude)
}

// double latitude = 2;
inline void Location::clear_latitude() {
  _impl_.latitude_ = 0;
}
inline double Location::_internal_latitude() const {
  return _impl_.latitude_;
}
inline double Location::latitude() const {
  // @@protoc_insertion_point(field_get:octopus.Location.latitude)
  return _internal_latitude();
}
inline void Location::_internal_set_latitude(double value) {
  
  _impl_.latitude_ = value;
}
inline void Location::set_latitude(double value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:octopus.Location.latitude)
}

// -------------------------------------------------------------------

// Link

// string title = 1;
inline void Link::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& Link::title() const {
  // @@protoc_insertion_point(field_get:octopus.Link.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Link::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:octopus.Link.title)
}
inline std::string* Link::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:octopus.Link.title)
  return _s;
}
inline const std::string& Link::_internal_title() const {
  return _impl_.title_.Get();
}
inline void Link::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* Link::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* Link::release_title() {
  // @@protoc_insertion_point(field_release:octopus.Link.title)
  return _impl_.title_.Release();
}
inline void Link::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:octopus.Link.title)
}

// string description = 2;
inline void Link::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Link::description() const {
  // @@protoc_insertion_point(field_get:octopus.Link.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Link::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:octopus.Link.description)
}
inline std::string* Link::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:octopus.Link.description)
  return _s;
}
inline const std::string& Link::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Link::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Link::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Link::release_description() {
  // @@protoc_insertion_point(field_release:octopus.Link.description)
  return _impl_.description_.Release();
}
inline void Link::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:octopus.Link.description)
}

// string url = 3;
inline void Link::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& Link::url() const {
  // @@protoc_insertion_point(field_get:octopus.Link.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Link::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:octopus.Link.url)
}
inline std::string* Link::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:octopus.Link.url)
  return _s;
}
inline const std::string& Link::_internal_url() const {
  return _impl_.url_.Get();
}
inline void Link::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* Link::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* Link::release_url() {
  // @@protoc_insertion_point(field_release:octopus.Link.url)
  return _impl_.url_.Release();
}
inline void Link::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:octopus.Link.url)
}

// -------------------------------------------------------------------

// User

// string uid = 1;
inline void User::clear_uid() {
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& User::uid() const {
  // @@protoc_insertion_point(field_get:octopus.User.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_uid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:octopus.User.uid)
}
inline std::string* User::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:octopus.User.uid)
  return _s;
}
inline const std::string& User::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void User::_internal_set_uid(const std::string& value) {
  
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_uid() {
  
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_uid() {
  // @@protoc_insertion_point(field_release:octopus.User.uid)
  return _impl_.uid_.Release();
}
inline void User::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:octopus.User.uid)
}

// string username = 2;
inline void User::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& User::username() const {
  // @@protoc_insertion_point(field_get:octopus.User.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:octopus.User.username)
}
inline std::string* User::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:octopus.User.username)
  return _s;
}
inline const std::string& User::_internal_username() const {
  return _impl_.username_.Get();
}
inline void User::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_username() {
  // @@protoc_insertion_point(field_release:octopus.User.username)
  return _impl_.username_.Release();
}
inline void User::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:octopus.User.username)
}

// string remark = 3;
inline void User::clear_remark() {
  _impl_.remark_.ClearToEmpty();
}
inline const std::string& User::remark() const {
  // @@protoc_insertion_point(field_get:octopus.User.remark)
  return _internal_remark();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_remark(ArgT0&& arg0, ArgT... args) {
 
 _impl_.remark_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:octopus.User.remark)
}
inline std::string* User::mutable_remark() {
  std::string* _s = _internal_mutable_remark();
  // @@protoc_insertion_point(field_mutable:octopus.User.remark)
  return _s;
}
inline const std::string& User::_internal_remark() const {
  return _impl_.remark_.Get();
}
inline void User::_internal_set_remark(const std::string& value) {
  
  _impl_.remark_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_remark() {
  
  return _impl_.remark_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_remark() {
  // @@protoc_insertion_point(field_release:octopus.User.remark)
  return _impl_.remark_.Release();
}
inline void User::set_allocated_remark(std::string* remark) {
  if (remark != nullptr) {
    
  } else {
    
  }
  _impl_.remark_.SetAllocated(remark, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.remark_.IsDefault()) {
    _impl_.remark_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:octopus.User.remark)
}

// -------------------------------------------------------------------

// Chat

// string uid = 1;
inline void Chat::clear_uid() {
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& Chat::uid() const {
  // @@protoc_insertion_point(field_get:octopus.Chat.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Chat::set_uid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:octopus.Chat.uid)
}
inline std::string* Chat::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:octopus.Chat.uid)
  return _s;
}
inline const std::string& Chat::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void Chat::_internal_set_uid(const std::string& value) {
  
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* Chat::_internal_mutable_uid() {
  
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* Chat::release_uid() {
  // @@protoc_insertion_point(field_release:octopus.Chat.uid)
  return _impl_.uid_.Release();
}
inline void Chat::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:octopus.Chat.uid)
}

// .octopus.Chat.ChatType type = 2;
inline void Chat::clear_type() {
  _impl_.type_ = 0;
}
inline ::octopus::Chat_ChatType Chat::_internal_type() const {
  return static_cast< ::octopus::Chat_ChatType >(_impl_.type_);
}
inline ::octopus::Chat_ChatType Chat::type() const {
  // @@protoc_insertion_point(field_get:octopus.Chat.type)
  return _internal_type();
}
inline void Chat::_internal_set_type(::octopus::Chat_ChatType value) {
  
  _impl_.type_ = value;
}
inline void Chat::set_type(::octopus::Chat_ChatType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:octopus.Chat.type)
}

// string title = 3;
inline void Chat::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& Chat::title() const {
  // @@protoc_insertion_point(field_get:octopus.Chat.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Chat::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:octopus.Chat.title)
}
inline std::string* Chat::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:octopus.Chat.title)
  return _s;
}
inline const std::string& Chat::_internal_title() const {
  return _impl_.title_.Get();
}
inline void Chat::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* Chat::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* Chat::release_title() {
  // @@protoc_insertion_point(field_release:octopus.Chat.title)
  return _impl_.title_.Release();
}
inline void Chat::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:octopus.Chat.title)
}

// -------------------------------------------------------------------

// Message

// int64 message_id = 1;
inline void Message::clear_message_id() {
  _impl_.message_id_ = int64_t{0};
}
inline int64_t Message::_internal_message_id() const {
  return _impl_.message_id_;
}
inline int64_t Message::message_id() const {
  // @@protoc_insertion_point(field_get:octopus.Message.message_id)
  return _internal_message_id();
}
inline void Message::_internal_set_message_id(int64_t value) {
  
  _impl_.message_id_ = value;
}
inline void Message::set_message_id(int64_t value) {
  _internal_set_message_id(value);
  // @@protoc_insertion_point(field_set:octopus.Message.message_id)
}

// int64 date = 2;
inline void Message::clear_date() {
  _impl_.date_ = int64_t{0};
}
inline int64_t Message::_internal_date() const {
  return _impl_.date_;
}
inline int64_t Message::date() const {
  // @@protoc_insertion_point(field_get:octopus.Message.date)
  return _internal_date();
}
inline void Message::_internal_set_date(int64_t value) {
  
  _impl_.date_ = value;
}
inline void Message::set_date(int64_t value) {
  _internal_set_date(value);
  // @@protoc_insertion_point(field_set:octopus.Message.date)
}

// int64 edit_date = 3;
inline void Message::clear_edit_date() {
  _impl_.edit_date_ = int64_t{0};
}
inline int64_t Message::_internal_edit_date() const {
  return _impl_.edit_date_;
}
inline int64_t Message::edit_date() const {
  // @@protoc_insertion_point(field_get:octopus.Message.edit_date)
  return _internal_edit_date();
}
inline void Message::_internal_set_edit_date(int64_t value) {
  
  _impl_.edit_date_ = value;
}
inline void Message::set_edit_date(int64_t value) {
  _internal_set_edit_date(value);
  // @@protoc_insertion_point(field_set:octopus.Message.edit_date)
}

// .octopus.User from = 4;
inline bool Message::_internal_has_from() const {
  return this != internal_default_instance() && _impl_.from_ != nullptr;
}
inline bool Message::has_from() const {
  return _internal_has_from();
}
inline void Message::clear_from() {
  if (GetArenaForAllocation() == nullptr && _impl_.from_ != nullptr) {
    delete _impl_.from_;
  }
  _impl_.from_ = nullptr;
}
inline const ::octopus::User& Message::_internal_from() const {
  const ::octopus::User* p = _impl_.from_;
  return p != nullptr ? *p : reinterpret_cast<const ::octopus::User&>(
      ::octopus::_User_default_instance_);
}
inline const ::octopus::User& Message::from() const {
  // @@protoc_insertion_point(field_get:octopus.Message.from)
  return _internal_from();
}
inline void Message::unsafe_arena_set_allocated_from(
    ::octopus::User* from) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.from_);
  }
  _impl_.from_ = from;
  if (from) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:octopus.Message.from)
}
inline ::octopus::User* Message::release_from() {
  
  ::octopus::User* temp = _impl_.from_;
  _impl_.from_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::octopus::User* Message::unsafe_arena_release_from() {
  // @@protoc_insertion_point(field_release:octopus.Message.from)
  
  ::octopus::User* temp = _impl_.from_;
  _impl_.from_ = nullptr;
  return temp;
}
inline ::octopus::User* Message::_internal_mutable_from() {
  
  if (_impl_.from_ == nullptr) {
    auto* p = CreateMaybeMessage<::octopus::User>(GetArenaForAllocation());
    _impl_.from_ = p;
  }
  return _impl_.from_;
}
inline ::octopus::User* Message::mutable_from() {
  ::octopus::User* _msg = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:octopus.Message.from)
  return _msg;
}
inline void Message::set_allocated_from(::octopus::User* from) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.from_;
  }
  if (from) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(from);
    if (message_arena != submessage_arena) {
      from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, from, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.from_ = from;
  // @@protoc_insertion_point(field_set_allocated:octopus.Message.from)
}

// .octopus.Chat Chat = 5;
inline bool Message::_internal_has_chat() const {
  return this != internal_default_instance() && _impl_.chat_ != nullptr;
}
inline bool Message::has_chat() const {
  return _internal_has_chat();
}
inline void Message::clear_chat() {
  if (GetArenaForAllocation() == nullptr && _impl_.chat_ != nullptr) {
    delete _impl_.chat_;
  }
  _impl_.chat_ = nullptr;
}
inline const ::octopus::Chat& Message::_internal_chat() const {
  const ::octopus::Chat* p = _impl_.chat_;
  return p != nullptr ? *p : reinterpret_cast<const ::octopus::Chat&>(
      ::octopus::_Chat_default_instance_);
}
inline const ::octopus::Chat& Message::chat() const {
  // @@protoc_insertion_point(field_get:octopus.Message.Chat)
  return _internal_chat();
}
inline void Message::unsafe_arena_set_allocated_chat(
    ::octopus::Chat* chat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chat_);
  }
  _impl_.chat_ = chat;
  if (chat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:octopus.Message.Chat)
}
inline ::octopus::Chat* Message::release_chat() {
  
  ::octopus::Chat* temp = _impl_.chat_;
  _impl_.chat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::octopus::Chat* Message::unsafe_arena_release_chat() {
  // @@protoc_insertion_point(field_release:octopus.Message.Chat)
  
  ::octopus::Chat* temp = _impl_.chat_;
  _impl_.chat_ = nullptr;
  return temp;
}
inline ::octopus::Chat* Message::_internal_mutable_chat() {
  
  if (_impl_.chat_ == nullptr) {
    auto* p = CreateMaybeMessage<::octopus::Chat>(GetArenaForAllocation());
    _impl_.chat_ = p;
  }
  return _impl_.chat_;
}
inline ::octopus::Chat* Message::mutable_chat() {
  ::octopus::Chat* _msg = _internal_mutable_chat();
  // @@protoc_insertion_point(field_mutable:octopus.Message.Chat)
  return _msg;
}
inline void Message::set_allocated_chat(::octopus::Chat* chat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chat_;
  }
  if (chat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chat);
    if (message_arena != submessage_arena) {
      chat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chat, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.chat_ = chat;
  // @@protoc_insertion_point(field_set_allocated:octopus.Message.Chat)
}

// string text = 6;
inline void Message::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& Message::text() const {
  // @@protoc_insertion_point(field_get:octopus.Message.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:octopus.Message.text)
}
inline std::string* Message::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:octopus.Message.text)
  return _s;
}
inline const std::string& Message::_internal_text() const {
  return _impl_.text_.Get();
}
inline void Message::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_text() {
  // @@protoc_insertion_point(field_release:octopus.Message.text)
  return _impl_.text_.Release();
}
inline void Message::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:octopus.Message.text)
}

// .octopus.Message reply_to_message = 7;
inline bool Message::_internal_has_reply_to_message() const {
  return this != internal_default_instance() && _impl_.reply_to_message_ != nullptr;
}
inline bool Message::has_reply_to_message() const {
  return _internal_has_reply_to_message();
}
inline void Message::clear_reply_to_message() {
  if (GetArenaForAllocation() == nullptr && _impl_.reply_to_message_ != nullptr) {
    delete _impl_.reply_to_message_;
  }
  _impl_.reply_to_message_ = nullptr;
}
inline const ::octopus::Message& Message::_internal_reply_to_message() const {
  const ::octopus::Message* p = _impl_.reply_to_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::octopus::Message&>(
      ::octopus::_Message_default_instance_);
}
inline const ::octopus::Message& Message::reply_to_message() const {
  // @@protoc_insertion_point(field_get:octopus.Message.reply_to_message)
  return _internal_reply_to_message();
}
inline void Message::unsafe_arena_set_allocated_reply_to_message(
    ::octopus::Message* reply_to_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reply_to_message_);
  }
  _impl_.reply_to_message_ = reply_to_message;
  if (reply_to_message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:octopus.Message.reply_to_message)
}
inline ::octopus::Message* Message::release_reply_to_message() {
  
  ::octopus::Message* temp = _impl_.reply_to_message_;
  _impl_.reply_to_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::octopus::Message* Message::unsafe_arena_release_reply_to_message() {
  // @@protoc_insertion_point(field_release:octopus.Message.reply_to_message)
  
  ::octopus::Message* temp = _impl_.reply_to_message_;
  _impl_.reply_to_message_ = nullptr;
  return temp;
}
inline ::octopus::Message* Message::_internal_mutable_reply_to_message() {
  
  if (_impl_.reply_to_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::octopus::Message>(GetArenaForAllocation());
    _impl_.reply_to_message_ = p;
  }
  return _impl_.reply_to_message_;
}
inline ::octopus::Message* Message::mutable_reply_to_message() {
  ::octopus::Message* _msg = _internal_mutable_reply_to_message();
  // @@protoc_insertion_point(field_mutable:octopus.Message.reply_to_message)
  return _msg;
}
inline void Message::set_allocated_reply_to_message(::octopus::Message* reply_to_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.reply_to_message_;
  }
  if (reply_to_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reply_to_message);
    if (message_arena != submessage_arena) {
      reply_to_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reply_to_message, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.reply_to_message_ = reply_to_message;
  // @@protoc_insertion_point(field_set_allocated:octopus.Message.reply_to_message)
}

// .octopus.Message.MessageType type = 99;
inline void Message::clear_type() {
  _impl_.type_ = 0;
}
inline ::octopus::Message_MessageType Message::_internal_type() const {
  return static_cast< ::octopus::Message_MessageType >(_impl_.type_);
}
inline ::octopus::Message_MessageType Message::type() const {
  // @@protoc_insertion_point(field_get:octopus.Message.type)
  return _internal_type();
}
inline void Message::_internal_set_type(::octopus::Message_MessageType value) {
  
  _impl_.type_ = value;
}
inline void Message::set_type(::octopus::Message_MessageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:octopus.Message.type)
}

// repeated .octopus.Photo photos = 100;
inline int Message::_internal_photos_size() const {
  return _impl_.photos_.size();
}
inline int Message::photos_size() const {
  return _internal_photos_size();
}
inline void Message::clear_photos() {
  _impl_.photos_.Clear();
}
inline ::octopus::Photo* Message::mutable_photos(int index) {
  // @@protoc_insertion_point(field_mutable:octopus.Message.photos)
  return _impl_.photos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::octopus::Photo >*
Message::mutable_photos() {
  // @@protoc_insertion_point(field_mutable_list:octopus.Message.photos)
  return &_impl_.photos_;
}
inline const ::octopus::Photo& Message::_internal_photos(int index) const {
  return _impl_.photos_.Get(index);
}
inline const ::octopus::Photo& Message::photos(int index) const {
  // @@protoc_insertion_point(field_get:octopus.Message.photos)
  return _internal_photos(index);
}
inline ::octopus::Photo* Message::_internal_add_photos() {
  return _impl_.photos_.Add();
}
inline ::octopus::Photo* Message::add_photos() {
  ::octopus::Photo* _add = _internal_add_photos();
  // @@protoc_insertion_point(field_add:octopus.Message.photos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::octopus::Photo >&
Message::photos() const {
  // @@protoc_insertion_point(field_list:octopus.Message.photos)
  return _impl_.photos_;
}

// .octopus.Video video = 101;
inline bool Message::_internal_has_video() const {
  return this != internal_default_instance() && _impl_.video_ != nullptr;
}
inline bool Message::has_video() const {
  return _internal_has_video();
}
inline void Message::clear_video() {
  if (GetArenaForAllocation() == nullptr && _impl_.video_ != nullptr) {
    delete _impl_.video_;
  }
  _impl_.video_ = nullptr;
}
inline const ::octopus::Video& Message::_internal_video() const {
  const ::octopus::Video* p = _impl_.video_;
  return p != nullptr ? *p : reinterpret_cast<const ::octopus::Video&>(
      ::octopus::_Video_default_instance_);
}
inline const ::octopus::Video& Message::video() const {
  // @@protoc_insertion_point(field_get:octopus.Message.video)
  return _internal_video();
}
inline void Message::unsafe_arena_set_allocated_video(
    ::octopus::Video* video) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.video_);
  }
  _impl_.video_ = video;
  if (video) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:octopus.Message.video)
}
inline ::octopus::Video* Message::release_video() {
  
  ::octopus::Video* temp = _impl_.video_;
  _impl_.video_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::octopus::Video* Message::unsafe_arena_release_video() {
  // @@protoc_insertion_point(field_release:octopus.Message.video)
  
  ::octopus::Video* temp = _impl_.video_;
  _impl_.video_ = nullptr;
  return temp;
}
inline ::octopus::Video* Message::_internal_mutable_video() {
  
  if (_impl_.video_ == nullptr) {
    auto* p = CreateMaybeMessage<::octopus::Video>(GetArenaForAllocation());
    _impl_.video_ = p;
  }
  return _impl_.video_;
}
inline ::octopus::Video* Message::mutable_video() {
  ::octopus::Video* _msg = _internal_mutable_video();
  // @@protoc_insertion_point(field_mutable:octopus.Message.video)
  return _msg;
}
inline void Message::set_allocated_video(::octopus::Video* video) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.video_;
  }
  if (video) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(video);
    if (message_arena != submessage_arena) {
      video = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, video, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.video_ = video;
  // @@protoc_insertion_point(field_set_allocated:octopus.Message.video)
}

// .octopus.File file = 102;
inline bool Message::_internal_has_file() const {
  return this != internal_default_instance() && _impl_.file_ != nullptr;
}
inline bool Message::has_file() const {
  return _internal_has_file();
}
inline void Message::clear_file() {
  if (GetArenaForAllocation() == nullptr && _impl_.file_ != nullptr) {
    delete _impl_.file_;
  }
  _impl_.file_ = nullptr;
}
inline const ::octopus::File& Message::_internal_file() const {
  const ::octopus::File* p = _impl_.file_;
  return p != nullptr ? *p : reinterpret_cast<const ::octopus::File&>(
      ::octopus::_File_default_instance_);
}
inline const ::octopus::File& Message::file() const {
  // @@protoc_insertion_point(field_get:octopus.Message.file)
  return _internal_file();
}
inline void Message::unsafe_arena_set_allocated_file(
    ::octopus::File* file) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.file_);
  }
  _impl_.file_ = file;
  if (file) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:octopus.Message.file)
}
inline ::octopus::File* Message::release_file() {
  
  ::octopus::File* temp = _impl_.file_;
  _impl_.file_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::octopus::File* Message::unsafe_arena_release_file() {
  // @@protoc_insertion_point(field_release:octopus.Message.file)
  
  ::octopus::File* temp = _impl_.file_;
  _impl_.file_ = nullptr;
  return temp;
}
inline ::octopus::File* Message::_internal_mutable_file() {
  
  if (_impl_.file_ == nullptr) {
    auto* p = CreateMaybeMessage<::octopus::File>(GetArenaForAllocation());
    _impl_.file_ = p;
  }
  return _impl_.file_;
}
inline ::octopus::File* Message::mutable_file() {
  ::octopus::File* _msg = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:octopus.Message.file)
  return _msg;
}
inline void Message::set_allocated_file(::octopus::File* file) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.file_;
  }
  if (file) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(file);
    if (message_arena != submessage_arena) {
      file = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, file, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.file_ = file;
  // @@protoc_insertion_point(field_set_allocated:octopus.Message.file)
}

// .octopus.Voice voice = 103;
inline bool Message::_internal_has_voice() const {
  return this != internal_default_instance() && _impl_.voice_ != nullptr;
}
inline bool Message::has_voice() const {
  return _internal_has_voice();
}
inline void Message::clear_voice() {
  if (GetArenaForAllocation() == nullptr && _impl_.voice_ != nullptr) {
    delete _impl_.voice_;
  }
  _impl_.voice_ = nullptr;
}
inline const ::octopus::Voice& Message::_internal_voice() const {
  const ::octopus::Voice* p = _impl_.voice_;
  return p != nullptr ? *p : reinterpret_cast<const ::octopus::Voice&>(
      ::octopus::_Voice_default_instance_);
}
inline const ::octopus::Voice& Message::voice() const {
  // @@protoc_insertion_point(field_get:octopus.Message.voice)
  return _internal_voice();
}
inline void Message::unsafe_arena_set_allocated_voice(
    ::octopus::Voice* voice) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voice_);
  }
  _impl_.voice_ = voice;
  if (voice) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:octopus.Message.voice)
}
inline ::octopus::Voice* Message::release_voice() {
  
  ::octopus::Voice* temp = _impl_.voice_;
  _impl_.voice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::octopus::Voice* Message::unsafe_arena_release_voice() {
  // @@protoc_insertion_point(field_release:octopus.Message.voice)
  
  ::octopus::Voice* temp = _impl_.voice_;
  _impl_.voice_ = nullptr;
  return temp;
}
inline ::octopus::Voice* Message::_internal_mutable_voice() {
  
  if (_impl_.voice_ == nullptr) {
    auto* p = CreateMaybeMessage<::octopus::Voice>(GetArenaForAllocation());
    _impl_.voice_ = p;
  }
  return _impl_.voice_;
}
inline ::octopus::Voice* Message::mutable_voice() {
  ::octopus::Voice* _msg = _internal_mutable_voice();
  // @@protoc_insertion_point(field_mutable:octopus.Message.voice)
  return _msg;
}
inline void Message::set_allocated_voice(::octopus::Voice* voice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.voice_;
  }
  if (voice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(voice);
    if (message_arena != submessage_arena) {
      voice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voice, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.voice_ = voice;
  // @@protoc_insertion_point(field_set_allocated:octopus.Message.voice)
}

// .octopus.Sticker sticker = 104;
inline bool Message::_internal_has_sticker() const {
  return this != internal_default_instance() && _impl_.sticker_ != nullptr;
}
inline bool Message::has_sticker() const {
  return _internal_has_sticker();
}
inline void Message::clear_sticker() {
  if (GetArenaForAllocation() == nullptr && _impl_.sticker_ != nullptr) {
    delete _impl_.sticker_;
  }
  _impl_.sticker_ = nullptr;
}
inline const ::octopus::Sticker& Message::_internal_sticker() const {
  const ::octopus::Sticker* p = _impl_.sticker_;
  return p != nullptr ? *p : reinterpret_cast<const ::octopus::Sticker&>(
      ::octopus::_Sticker_default_instance_);
}
inline const ::octopus::Sticker& Message::sticker() const {
  // @@protoc_insertion_point(field_get:octopus.Message.sticker)
  return _internal_sticker();
}
inline void Message::unsafe_arena_set_allocated_sticker(
    ::octopus::Sticker* sticker) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sticker_);
  }
  _impl_.sticker_ = sticker;
  if (sticker) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:octopus.Message.sticker)
}
inline ::octopus::Sticker* Message::release_sticker() {
  
  ::octopus::Sticker* temp = _impl_.sticker_;
  _impl_.sticker_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::octopus::Sticker* Message::unsafe_arena_release_sticker() {
  // @@protoc_insertion_point(field_release:octopus.Message.sticker)
  
  ::octopus::Sticker* temp = _impl_.sticker_;
  _impl_.sticker_ = nullptr;
  return temp;
}
inline ::octopus::Sticker* Message::_internal_mutable_sticker() {
  
  if (_impl_.sticker_ == nullptr) {
    auto* p = CreateMaybeMessage<::octopus::Sticker>(GetArenaForAllocation());
    _impl_.sticker_ = p;
  }
  return _impl_.sticker_;
}
inline ::octopus::Sticker* Message::mutable_sticker() {
  ::octopus::Sticker* _msg = _internal_mutable_sticker();
  // @@protoc_insertion_point(field_mutable:octopus.Message.sticker)
  return _msg;
}
inline void Message::set_allocated_sticker(::octopus::Sticker* sticker) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sticker_;
  }
  if (sticker) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sticker);
    if (message_arena != submessage_arena) {
      sticker = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sticker, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sticker_ = sticker;
  // @@protoc_insertion_point(field_set_allocated:octopus.Message.sticker)
}

// .octopus.Location location = 105;
inline bool Message::_internal_has_location() const {
  return this != internal_default_instance() && _impl_.location_ != nullptr;
}
inline bool Message::has_location() const {
  return _internal_has_location();
}
inline void Message::clear_location() {
  if (GetArenaForAllocation() == nullptr && _impl_.location_ != nullptr) {
    delete _impl_.location_;
  }
  _impl_.location_ = nullptr;
}
inline const ::octopus::Location& Message::_internal_location() const {
  const ::octopus::Location* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::octopus::Location&>(
      ::octopus::_Location_default_instance_);
}
inline const ::octopus::Location& Message::location() const {
  // @@protoc_insertion_point(field_get:octopus.Message.location)
  return _internal_location();
}
inline void Message::unsafe_arena_set_allocated_location(
    ::octopus::Location* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:octopus.Message.location)
}
inline ::octopus::Location* Message::release_location() {
  
  ::octopus::Location* temp = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::octopus::Location* Message::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:octopus.Message.location)
  
  ::octopus::Location* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::octopus::Location* Message::_internal_mutable_location() {
  
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::octopus::Location>(GetArenaForAllocation());
    _impl_.location_ = p;
  }
  return _impl_.location_;
}
inline ::octopus::Location* Message::mutable_location() {
  ::octopus::Location* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:octopus.Message.location)
  return _msg;
}
inline void Message::set_allocated_location(::octopus::Location* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.location_ = location;
  // @@protoc_insertion_point(field_set_allocated:octopus.Message.location)
}

// .octopus.Link link = 106;
inline bool Message::_internal_has_link() const {
  return this != internal_default_instance() && _impl_.link_ != nullptr;
}
inline bool Message::has_link() const {
  return _internal_has_link();
}
inline void Message::clear_link() {
  if (GetArenaForAllocation() == nullptr && _impl_.link_ != nullptr) {
    delete _impl_.link_;
  }
  _impl_.link_ = nullptr;
}
inline const ::octopus::Link& Message::_internal_link() const {
  const ::octopus::Link* p = _impl_.link_;
  return p != nullptr ? *p : reinterpret_cast<const ::octopus::Link&>(
      ::octopus::_Link_default_instance_);
}
inline const ::octopus::Link& Message::link() const {
  // @@protoc_insertion_point(field_get:octopus.Message.link)
  return _internal_link();
}
inline void Message::unsafe_arena_set_allocated_link(
    ::octopus::Link* link) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.link_);
  }
  _impl_.link_ = link;
  if (link) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:octopus.Message.link)
}
inline ::octopus::Link* Message::release_link() {
  
  ::octopus::Link* temp = _impl_.link_;
  _impl_.link_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::octopus::Link* Message::unsafe_arena_release_link() {
  // @@protoc_insertion_point(field_release:octopus.Message.link)
  
  ::octopus::Link* temp = _impl_.link_;
  _impl_.link_ = nullptr;
  return temp;
}
inline ::octopus::Link* Message::_internal_mutable_link() {
  
  if (_impl_.link_ == nullptr) {
    auto* p = CreateMaybeMessage<::octopus::Link>(GetArenaForAllocation());
    _impl_.link_ = p;
  }
  return _impl_.link_;
}
inline ::octopus::Link* Message::mutable_link() {
  ::octopus::Link* _msg = _internal_mutable_link();
  // @@protoc_insertion_point(field_mutable:octopus.Message.link)
  return _msg;
}
inline void Message::set_allocated_link(::octopus::Link* link) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.link_;
  }
  if (link) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(link);
    if (message_arena != submessage_arena) {
      link = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, link, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.link_ = link;
  // @@protoc_insertion_point(field_set_allocated:octopus.Message.link)
}

// -------------------------------------------------------------------

// Vendor

// string uid = 1;
inline void Vendor::clear_uid() {
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& Vendor::uid() const {
  // @@protoc_insertion_point(field_get:octopus.Vendor.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Vendor::set_uid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:octopus.Vendor.uid)
}
inline std::string* Vendor::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:octopus.Vendor.uid)
  return _s;
}
inline const std::string& Vendor::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void Vendor::_internal_set_uid(const std::string& value) {
  
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* Vendor::_internal_mutable_uid() {
  
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* Vendor::release_uid() {
  // @@protoc_insertion_point(field_release:octopus.Vendor.uid)
  return _impl_.uid_.Release();
}
inline void Vendor::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:octopus.Vendor.uid)
}

// string type = 2;
inline void Vendor::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Vendor::type() const {
  // @@protoc_insertion_point(field_get:octopus.Vendor.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Vendor::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:octopus.Vendor.type)
}
inline std::string* Vendor::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:octopus.Vendor.type)
  return _s;
}
inline const std::string& Vendor::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Vendor::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Vendor::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Vendor::release_type() {
  // @@protoc_insertion_point(field_release:octopus.Vendor.type)
  return _impl_.type_.Release();
}
inline void Vendor::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:octopus.Vendor.type)
}

// -------------------------------------------------------------------

// Payload

// string uid = 1;
inline void Payload::clear_uid() {
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& Payload::uid() const {
  // @@protoc_insertion_point(field_get:octopus.Payload.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Payload::set_uid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:octopus.Payload.uid)
}
inline std::string* Payload::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:octopus.Payload.uid)
  return _s;
}
inline const std::string& Payload::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void Payload::_internal_set_uid(const std::string& value) {
  
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* Payload::_internal_mutable_uid() {
  
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* Payload::release_uid() {
  // @@protoc_insertion_point(field_release:octopus.Payload.uid)
  return _impl_.uid_.Release();
}
inline void Payload::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:octopus.Payload.uid)
}

// .octopus.Vendor vendor = 2;
inline bool Payload::_internal_has_vendor() const {
  return this != internal_default_instance() && _impl_.vendor_ != nullptr;
}
inline bool Payload::has_vendor() const {
  return _internal_has_vendor();
}
inline void Payload::clear_vendor() {
  if (GetArenaForAllocation() == nullptr && _impl_.vendor_ != nullptr) {
    delete _impl_.vendor_;
  }
  _impl_.vendor_ = nullptr;
}
inline const ::octopus::Vendor& Payload::_internal_vendor() const {
  const ::octopus::Vendor* p = _impl_.vendor_;
  return p != nullptr ? *p : reinterpret_cast<const ::octopus::Vendor&>(
      ::octopus::_Vendor_default_instance_);
}
inline const ::octopus::Vendor& Payload::vendor() const {
  // @@protoc_insertion_point(field_get:octopus.Payload.vendor)
  return _internal_vendor();
}
inline void Payload::unsafe_arena_set_allocated_vendor(
    ::octopus::Vendor* vendor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vendor_);
  }
  _impl_.vendor_ = vendor;
  if (vendor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:octopus.Payload.vendor)
}
inline ::octopus::Vendor* Payload::release_vendor() {
  
  ::octopus::Vendor* temp = _impl_.vendor_;
  _impl_.vendor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::octopus::Vendor* Payload::unsafe_arena_release_vendor() {
  // @@protoc_insertion_point(field_release:octopus.Payload.vendor)
  
  ::octopus::Vendor* temp = _impl_.vendor_;
  _impl_.vendor_ = nullptr;
  return temp;
}
inline ::octopus::Vendor* Payload::_internal_mutable_vendor() {
  
  if (_impl_.vendor_ == nullptr) {
    auto* p = CreateMaybeMessage<::octopus::Vendor>(GetArenaForAllocation());
    _impl_.vendor_ = p;
  }
  return _impl_.vendor_;
}
inline ::octopus::Vendor* Payload::mutable_vendor() {
  ::octopus::Vendor* _msg = _internal_mutable_vendor();
  // @@protoc_insertion_point(field_mutable:octopus.Payload.vendor)
  return _msg;
}
inline void Payload::set_allocated_vendor(::octopus::Vendor* vendor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vendor_;
  }
  if (vendor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vendor);
    if (message_arena != submessage_arena) {
      vendor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vendor, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vendor_ = vendor;
  // @@protoc_insertion_point(field_set_allocated:octopus.Payload.vendor)
}

// .octopus.Payload.PayloadType type = 3;
inline void Payload::clear_type() {
  _impl_.type_ = 0;
}
inline ::octopus::Payload_PayloadType Payload::_internal_type() const {
  return static_cast< ::octopus::Payload_PayloadType >(_impl_.type_);
}
inline ::octopus::Payload_PayloadType Payload::type() const {
  // @@protoc_insertion_point(field_get:octopus.Payload.type)
  return _internal_type();
}
inline void Payload::_internal_set_type(::octopus::Payload_PayloadType value) {
  
  _impl_.type_ = value;
}
inline void Payload::set_type(::octopus::Payload_PayloadType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:octopus.Payload.type)
}

// repeated .octopus.Chat chats = 4;
inline int Payload::_internal_chats_size() const {
  return _impl_.chats_.size();
}
inline int Payload::chats_size() const {
  return _internal_chats_size();
}
inline void Payload::clear_chats() {
  _impl_.chats_.Clear();
}
inline ::octopus::Chat* Payload::mutable_chats(int index) {
  // @@protoc_insertion_point(field_mutable:octopus.Payload.chats)
  return _impl_.chats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::octopus::Chat >*
Payload::mutable_chats() {
  // @@protoc_insertion_point(field_mutable_list:octopus.Payload.chats)
  return &_impl_.chats_;
}
inline const ::octopus::Chat& Payload::_internal_chats(int index) const {
  return _impl_.chats_.Get(index);
}
inline const ::octopus::Chat& Payload::chats(int index) const {
  // @@protoc_insertion_point(field_get:octopus.Payload.chats)
  return _internal_chats(index);
}
inline ::octopus::Chat* Payload::_internal_add_chats() {
  return _impl_.chats_.Add();
}
inline ::octopus::Chat* Payload::add_chats() {
  ::octopus::Chat* _add = _internal_add_chats();
  // @@protoc_insertion_point(field_add:octopus.Payload.chats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::octopus::Chat >&
Payload::chats() const {
  // @@protoc_insertion_point(field_list:octopus.Payload.chats)
  return _impl_.chats_;
}

// .octopus.Message message = 5;
inline bool Payload::_internal_has_message() const {
  return this != internal_default_instance() && _impl_.message_ != nullptr;
}
inline bool Payload::has_message() const {
  return _internal_has_message();
}
inline void Payload::clear_message() {
  if (GetArenaForAllocation() == nullptr && _impl_.message_ != nullptr) {
    delete _impl_.message_;
  }
  _impl_.message_ = nullptr;
}
inline const ::octopus::Message& Payload::_internal_message() const {
  const ::octopus::Message* p = _impl_.message_;
  return p != nullptr ? *p : reinterpret_cast<const ::octopus::Message&>(
      ::octopus::_Message_default_instance_);
}
inline const ::octopus::Message& Payload::message() const {
  // @@protoc_insertion_point(field_get:octopus.Payload.message)
  return _internal_message();
}
inline void Payload::unsafe_arena_set_allocated_message(
    ::octopus::Message* message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.message_);
  }
  _impl_.message_ = message;
  if (message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:octopus.Payload.message)
}
inline ::octopus::Message* Payload::release_message() {
  
  ::octopus::Message* temp = _impl_.message_;
  _impl_.message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::octopus::Message* Payload::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:octopus.Payload.message)
  
  ::octopus::Message* temp = _impl_.message_;
  _impl_.message_ = nullptr;
  return temp;
}
inline ::octopus::Message* Payload::_internal_mutable_message() {
  
  if (_impl_.message_ == nullptr) {
    auto* p = CreateMaybeMessage<::octopus::Message>(GetArenaForAllocation());
    _impl_.message_ = p;
  }
  return _impl_.message_;
}
inline ::octopus::Message* Payload::mutable_message() {
  ::octopus::Message* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:octopus.Payload.message)
  return _msg;
}
inline void Payload::set_allocated_message(::octopus::Message* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(message);
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.message_ = message;
  // @@protoc_insertion_point(field_set_allocated:octopus.Payload.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace octopus

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::octopus::Chat_ChatType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::octopus::Chat_ChatType>() {
  return ::octopus::Chat_ChatType_descriptor();
}
template <> struct is_proto_enum< ::octopus::Message_MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::octopus::Message_MessageType>() {
  return ::octopus::Message_MessageType_descriptor();
}
template <> struct is_proto_enum< ::octopus::Payload_PayloadType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::octopus::Payload_PayloadType>() {
  return ::octopus::Payload_PayloadType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_octopus_2eproto
